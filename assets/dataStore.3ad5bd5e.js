import{s as m,k as c}from"./index.8838c464.js";import{u as l,q as f,l as p}from"./app.42c36b1f.js";import{localforage as u}from"./localForage.ca6e9d39.js";import{dayjs as o}from"./dayjs.106d80ab.js";const P=m("projectDataStore",{state:()=>({selectedProject:null,inProcess:{},pending:{},deployments:{},assignments:{},releases:{},releasesCurrentCount:{},projects:{},openRequest:{},pendingRequest:{},closedRequest:{},openClassifications:{},pendingClassifications:{},closedClassifications:{},nameRequest:{},requestedTimeStamps:{},trainingMatrixColumns:{},trainingMatrixInputs:{},disaReady:{},inventory:{}}),getters:{getInProcess:e=>t=>{if(t)return e.inProcess[t]?e.inProcess[t]:[];{let s=[];return Object.keys(e.inProcess).forEach(r=>{s=s.concat(e.inProcess[r])}),s}},getPending:e=>t=>{if(t)return e.pending[t]?e.pending[t]:[];{let s=[];return Object.keys(e.pending).forEach(r=>{s=s.concat(e.pending[r])}),s}},getDeployments:e=>t=>{if(t)return e.deployments[t]?e.deployments[t]:[];{let s=[];return Object.keys(e.deployments).forEach(r=>{s=s.concat(e.deployments[r])}),s}},getAssignments:e=>t=>{if(t)return e.assignments[t]?e.assignments[t]:[];{let s=[];return Object.keys(e.assignments).forEach(r=>{s=s.concat(e.assignments[r])}),s}},getReleases:e=>t=>{if(t)return e.releases[t]?e.releases[t]:[];{let s=[];return Object.keys(e.releases).forEach(r=>{s=s.concat(e.releases[r])}),s}},getCurrentReleaseCount:e=>t=>t?e.releasesCurrentCount[t]?e.releasesCurrentCount[t]:0:e.releasesCurrentCount.total,getOpenRequest:e=>t=>{if(t)return e.openRequest[t]?e.openRequest[t]:[];{let s=[];return Object.keys(e.openRequest).forEach(r=>{s=s.concat(e.openRequest[r])}),s}},getPendingRequest:e=>t=>{if(t)return e.pendingRequest[t]?e.pendingRequest[t]:[];{let s=[];return Object.keys(e.pendingRequest).forEach(r=>{s=s.concat(e.pendingRequest[r])}),s}},getClosedRequest:e=>t=>{if(t)return e.closedRequest[t]?e.closedRequest[t]:[];{let s=[];return Object.keys(e.closedRequest).forEach(r=>{s=s.concat(e.closedRequest[r])}),s}},getNameRequest:e=>t=>{if(t)return e.nameRequest[t]?e.nameRequest[t]:[];{let s=[];return Object.keys(e.nameRequest).forEach(r=>{s=s.concat(e.nameRequest[r])}),s}},getProjects:e=>(t,s)=>{if(!s&&!t){let r=[];return Object.keys(e.projects).forEach(n=>{r=r.concat(e.projects[n])}),r}else if(!s&&t){const{userProjects:r}=l();let n=[];return r(t).forEach(i=>{n=n.concat(e.projects[i[8]])}),n}else if(s&&t){const{getOffice:r}=l(),n=r(s);return t==="read"&&n&&n[39]!==!0?[]:(t==="create"||t==="update")&&n&&n[40]!==!0?[]:t==="manage"&&n&&n[41]!==!0?[]:e.projects[s]?e.projects[s]:[]}else return e.projects[s]?e.projects[s]:[]},getRequestedTimeStamps(e){return e.requestedTimeStamps},getselectedProject(e){return e.selectedProject},getMatrixColumns:e=>t=>{if(t)return e.trainingMatrixColumns[t]?e.trainingMatrixColumns[t]:[];{let s=[];return Object.keys(e.trainingMatrixColumns).forEach(r=>{s=s.concat(e.trainingMatrixColumns[r])}),s}},getMatrixInputs:e=>t=>t?e.trainingMatrixInputs[t]?e.trainingMatrixInputs[t]:[]:null,getDisaReady:e=>t=>t?e.disaReady[t]:!1,getInventory:e=>t=>t?e.inventory[t]?e.inventory[t]:null:e.inventory,getInventoryItems:e=>t=>t?e.inventory[t]?e.inventory[t].items:null:"ID is required"},actions:{setselectedProject(e,t){this.selectedProject=e},setTimeStamp({name:e,timeStamp:t,projectId:s},r){if(this.requestedTimeStamps[s]?this.requestedTimeStamps[s][e]=t:this.requestedTimeStamps[s]={[e]:t},r){const n=JSON.parse(JSON.stringify(this.requestedTimeStamps));u.setItem(`${c.storageProcessTimeStamps}`,n)}},setTimeStampState(e){this.requestedTimeStamps=e},async fetchInProcess(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"In Processes By Project"}}];if(t.inProcess&&(t.inProcess.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"inProcess",timeStamp:o()},!0);const{data:n}=await f.fetchFromHiringApp({fields:r});return this.setInProcess({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllInProcess(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchInProcess({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setInProcess({projectId:e,data:t},s){this.inProcess[e]=t,s&&u.setItem(`${c.storageInProcess}_${e}`,t)},async fetchPending(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Dispatches By Project"}}];if(t.pending&&(t.pending.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pending",timeStamp:o()},!0);const{data:n}=await f.fetchFromHiringApp({fields:r});return this.setPending({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllPending(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchPending({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setPending({projectId:e,data:t},s){this.pending[e]=t,s&&u.setItem(`${c.storagePending}_${e}`,t)},async fetchDeployments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Deployments By Project"}}];if(t.deployments&&(t.deployments.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"deployments",timeStamp:o()},!0);const{data:n}=await f.fetchFromHiringApp({fields:r});return this.setDeployments({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllDeployments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchDeployments({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},async setDeployments({projectId:e,data:t},s){this.deployments[e]=t,s&&u.setItem(`${c.storageDeployments}_${e}`,t)},updateDeployment({projectId:e,key:t,record:s}){const r=this.deployments[e].findIndex(n=>n[3]===t);r>-1&&(this.deployments[e][r]=s)},async fetchAssignments(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Assignments By Project"}}];if(t.assignments&&(t.assignments.isBefore(o().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"assignments",timeStamp:o()},!0);const{data:n}=await f.fetchFromHiringApp({fields:r});return this.setAssignments({projectId:e.projectId,data:n},!0),{data:n}}else return{data:this.getAssignments(e.projectId)}},async fetchAllAssignments(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchAssignments({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},async setAssignments({projectId:e,data:t},s){this.assignments[e]=t,s&&u.setItem(`${c.storageAssignments}_${e}`,t)},async fetchReleases(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;if(t.releases&&(t.releases.isBefore(o().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"releases",timeStamp:o()},!0);const{data:r,metadata:n}=await f.doQuery({from:"bp3ga39ut",where:`{'41'.EX.'${e.projectId}'}AND{'42'.XEX.'Rescinded'}AND{'42'.XEX.'Cancelled'}`,select:[80],sortBy:[{fieldId:1,order:"ASC"}],options:{top:e.top},queryObject:80,queryTotalRecords:!0});return this.setReleases({projectId:e.projectId,data:r,currentCount:n.totalRecords},!0),{data:r}}else return{data:this.getReleases(e.projectId)}},async fetchAllReleases(e){const{userProjects:t}=l(),s=[];let r=!1,n="(";if(t(e?e.access:null).forEach(a=>{const d=this.getRequestedTimeStamps[a[9]]||{};let h=!0;d.releases&&(d.releases.isBefore(o().subtract(5,"minute"))?h=!0:h=e.refresh?e.refresh:!1),h?(r=!0,n+=`{'41'.EX.'${a[9]}'}OR`,console.log("fetch releases")):console.log("no fetch releases")}),r){n+=")";const{data:a,metadata:d}=await f.doQuery({from:"bp3ga39ut",where:`${n}AND{'42'.XEX.'Rescinded'}AND{'42'.XEX.'Cancelled'}`,select:[80],sortBy:[{fieldId:1,order:"ASC"}],options:{top:e.top},queryObject:80,queryTotalRecords:!0});this.setMultiReleases({data:a,currentCount:d.totalRecords},!0)}return await Promise.allSettled(s)},setReleases({projectId:e,data:t,currentCount:s}){this.releases[e]=t,s&&(this.releasesCurrentCount[e]=s)},setMultiReleases({data:e,currentCount:t}){const s=p.exports.groupBy(e,"41");Object.keys(s).forEach(r=>{this.setReleases({projectId:r,data:s[r]},!0)}),t&&(this.releasesCurrentCount.total=t)},async fetchOpenRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Open Requests By Project"}}];if(t.openRequest&&(t.openRequest.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"openRequest",timeStamp:o()},!0);const{data:n}=await f.fetchFromProjectsApp({fields:r});return this.setOpenRequest({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllOpenRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchOpenRequest({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setOpenRequest({projectId:e,data:t},s){this.openRequest[e]=t,s&&u.setItem(`${c.storageOpenRequest}_${e}`,t)},async fetchPendingRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Pending Requests By Project"}}];if(t.pendingRequest&&(t.pendingRequest.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingRequest",timeStamp:o()},!0);const{data:n}=await f.fetchFromProjectsApp({fields:r});return this.setPendingRequest({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllPendingRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchPendingRequest({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setPendingRequest({projectId:e,data:t},s){this.pendingRequest[e]=t,s&&u.setItem(`${c.storagePendingRequest}_${e}`,t)},async fetchClosedRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Closed Requests By Project Alt"}}];if(t.closedRequest&&(t.closedRequest.isBefore(o().subtract(5,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"closedRequest",timeStamp:o()},!0);const{data:n}=await f.fetchFromProjectsApp({fields:r});return this.setClosedRequest({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllClosedRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchClosedRequest({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setClosedRequest({projectId:e,data:t},s){this.closedRequest[e]=t,s&&u.setItem(`${c.storageClosedRequest}_${e}`,t)},async fetchNameRequest(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Name Requests By Project"}}];if(t.nameRequest&&(t.nameRequest.isBefore(o().subtract(2,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"nameRequest",timeStamp:o()},!0);const{data:n}=await f.fetchFromHiringApp({fields:r});return this.setNameRequest({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllNameRequest(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchNameRequest({...e,projectId:n[9]});s.push(i)}),await Promise.allSettled(s)},setNameRequest({projectId:e,data:t},s){this.nameRequest[e]=t,s&&u.setItem(`${c.storageNameRequest}_${e}`,t)},async fetchProjects(e){const{getOffice:t}=l(),s=this.getRequestedTimeStamps[e.projectId]||{};let r=!0;if(e&&e.access){const i=t(e.projectId);if(e.access==="read"&&i&&i[39]!==!0)return{data:[]};if((e.access==="create"||e.access==="update")&&i&&i[40]!==!0)return{data:[]};if(e.access==="manage"&&i&&i[41]!==!0)return{data:[]}}const n=[{9:{value:e.projectId},7:{value:"Projects"}}];if(s.projects&&(s.projects.isBefore(o().subtract(1,"minute"))?r=!0:r=e.refresh?e.refresh:!1),r){this.setTimeStamp({projectId:e.projectId,name:"projects",timeStamp:o()},!0);const{data:i}=await f.fetchFromProjectsApp({fields:n});return this.setProjects({projectId:e.projectId,data:i},!0),{data:i}}else return{data:[]}},async fetchAllProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchProjects({...e,projectId:n[8]});s.push(i)}),await Promise.allSettled(s)},setProjects({projectId:e,data:t},s){e&&t&&(this.projects[e]=t),s&&e&&u.setItem(`${c.storageProjects}_${e}`,t)},async fetchPendingProjects(e){const t=this.getRequestedTimeStamps[e.projectId]||{};let s=!0;const r=[{9:{value:e.projectId},7:{value:"Pending Projects"}}];if(t.pendingProjects&&(t.pendingProjects.isBefore(o().subtract(1,"minute"))?s=!0:s=e.refresh?e.refresh:!1),s){this.setTimeStamp({projectId:e.projectId,name:"pendingProjects",timeStamp:o()},!0);const{data:n}=await f.fetchFromProjectsApp({fields:r});return this.setPendingProjects({projectId:e.projectId,data:n},!0),{data:n}}else return{data:[]}},async fetchAllPendingProjects(e){const{userProjects:t}=l(),s=[];return t(e?e.access:null).forEach(n=>{let i=this.fetchPendingProjects({...e,projectId:n[8]});s.push(i)}),await Promise.allSettled(s)},setPendingProjects({projectId:e,data:t},s){this.pendingProjects[e]=t,s&&u.setItem(`${c.storagePendingProjects}_${e}`,t)},setMatrixColumns({id:e,data:t},s){e&&t&&(this.trainingMatrixColumns[e]=t),s&&e&&u.setItem(`clm_proj_matrix_columns_${e}`,t)},setMatrixInputs({id:e,data:t},s){e&&t&&(this.trainingMatrixInputs[e]=t),s&&e&&u.setItem(`clm_proj_matrix_inputs_${e}`,t)},setDisaStatus({assignmentId:e,id:t,projectId:s,data:r}){if(this.assignments[s]){const n=this.assignments[s].findIndex(i=>i[3]===e);n>-1&&(this.assignments[s][n].employee[556]=r)}},setDisaReady({id:e}){this.disaReady[e]=!0},setInventory({id:e,data:t}){this.inventory[e]=t},updateInventoryItems({id:e,data:t}){this.inventory[e]?this.inventory[e].items=t:this.inventory[e]={3:e,items:t}},async removeData({type:e,key:t,item:s,storageKey:r}){const n=this[e][t],i=n?this[e][t].findIndex(a=>a[3]===s[3]):-1;i>-1&&this[e][t].splice(i,1),u.removeItem(`${c[r]}_${t}`),n&&!u.getItem(`${c[r]}_${t}`)&&u.setItem(`${c[r]}_${t}`,n)}}});export{P as u};
